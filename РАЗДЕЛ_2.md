# 2. ОСНОВНАЯ ЧАСТЬ

## 2.2 Используемая информация

### 2.2.1 Данные пользователей и системы

**2.2.1.1 Учётные данные пользователя:**
- Логин (username) — уникальный идентификатор пользователя
- Хешированный пароль (passwordHash) — результат криптографического хеширования пароля с использованием соли
- Соль (salt) — случайная последовательность байтов для усиления стойкости хеша пароля
- Хеш seed-фразы (seedPhraseHash) — хешированная фраза восстановления для сброса пароля
- Соль хранилища (vaultSalt) — уникальная соль для шифрования персонального хранилища паролей пользователя

**2.2.1.2 Данные сессии:**
- Кодовое слово (codeWord) — мастер-ключ для шифрования/дешифрования хранилища паролей (хранится только на стороне клиента в оперативной памяти)
- Ключ шифрования хранилища (vaultKey) — производный ключ от кодового слова, используемый для AES-GCM шифрования
- Статус авторизации (isLoggedIn) — флаг активной сессии пользователя

**2.2.1.3 Системные настройки:**
- Порт сервера (по умолчанию 8080)
- Путь к файлу пользователей (users.json)
- Директория хранилищ паролей (server_vaults/)
- Параметры криптографии (размер ключей, алгоритмы хеширования и шифрования)

### 2.2.2 Сущности

**2.2.2.1 Пользователь (User):**

Хранится в структуре `HashTableUsers`:
- `login` (string) — логин пользователя
- `passwordHash` (string) — хеш пароля для аутентификации
- `salt` (string) — соль для хеширования пароля
- `seedPhraseHash` (string) — хеш seed-фразы для восстановления доступа
- `vaultSalt` (string) — соль для генерации ключа шифрования хранилища
- `isDelete` (bool) — флаг удаления записи
- `isNull` (bool) — флаг пустой ячейки хеш-таблицы

**2.2.2.2 Запись в хранилище паролей (VaultEntry):**

Хранится в структуре `UserHashTable`:
- `service` (string) — название сервиса/веб-сайта
- `login` (string) — логин для данного сервиса
- `password` (string) — пароль для данного сервиса (хранится в зашифрованном виде)
- `url` (string) — URL веб-сайта или адрес сервиса
- `note` (string) — дополнительные заметки или комментарии
- `lastModifiedTime` (string) — временная метка последнего изменения записи
- `isDelete` (bool) — флаг удаления записи
- `isNull` (bool) — флаг пустой ячейки хеш-таблицы

**2.2.2.3 Серверный компонент (Server):**
- `port` (int) — порт прослушивания TCP-соединений
- `serverSocket` (int) — дескриптор серверного сокета
- `usersFilePath` (string) — путь к файлу базы пользователей
- `vaultDirectory` (string) — директория хранения зашифрованных хранилищ

**2.2.2.4 Клиентский компонент (Client):**
- `serverHost` (string) — адрес сервера
- `serverPort` (int) — порт сервера
- `username` (string) — имя текущего пользователя
- `password` (string) — пароль (хранится только во время сессии)
- `codeWord` (string) — кодовое слово для шифрования хранилища
- `vault` (UserHashTable*) — локальная копия хранилища паролей
- `vaultKey` (vector<unsigned char>) — ключ шифрования хранилища
- `isLoggedIn` (bool) — статус авторизации

### 2.2.3 Данные мониторинга и логирования

**2.2.3.1 Сетевые операции:**
- TCP-соединения клиент-сервер
- JSON-запросы и ответы между компонентами системы
- Статусы операций (success/error) и коды ошибок

**2.2.3.2 Действия пользователей:**
- Регистрация новых пользователей
- Попытки входа в систему (успешные и неудачные)
- Операции с хранилищем (добавление, изменение, удаление записей)
- Синхронизация данных с сервером
- Восстановление доступа через seed-фразу

**2.2.3.3 Криптографические операции:**
- Генерация солей и ключей шифрования
- Операции хеширования паролей
- Шифрование и дешифрование хранилищ
- Валидация целостности зашифрованных данных

## 2.3 Результаты решения

Результатом решения задачи является функционирующий менеджер паролей с клиент-серверной архитектурой, предоставляющий:

1. **Графический интерфейс пользователя** на базе Qt Framework, обеспечивающий интуитивное взаимодействие со всеми функциями системы (регистрация, авторизация, управление паролями, оценка стойкости паролей).

2. **Серверную часть** для централизованного и безопасного хранения зашифрованных пользовательских данных с поддержкой множественных одновременных подключений.

3. **Систему криптографической защиты**, включающую:
   - Хеширование паролей с использованием Argon2 и уникальных солей
   - Шифрование хранилищ паролей с помощью AES-256-GCM
   - Генерацию криптостойких случайных паролей
   - Производные ключи на основе PBKDF2 для защиты данных

4. **Инструменты управления паролями:**
   - Генератор паролей с настраиваемыми параметрами (длина, набор символов)
   - Анализатор стойкости паролей с проверкой по словарям распространённых паролей
   - CRUD-операции для записей в хранилище
   - Поиск и фильтрация сохранённых паролей

5. **Механизм восстановления доступа** через seed-фразу (мнемоническую фразу восстановления).

6. **Возможность контейнеризации** серверной части с использованием Docker для упрощённого развёртывания.

## 2.4 Алгоритм решения задачи

Алгоритм решения задачи построен на архитектуре клиент-сервер с чётким разделением ответственности между компонентами. Клиентская часть, реализованная на базе Qt Framework, отвечает за пользовательский интерфейс, локальное управление хранилищем паролей и криптографические операции. Серверная часть на C++ обеспечивает сетевое взаимодействие, централизованное хранение зашифрованных данных и обработку запросов множественных клиентов.

Общий подход к реализации основывается на модульной структуре, где каждый функциональный блок (аутентификация, работа с хранилищем, криптография, сетевое взаимодействие) разрабатывается как независимый компонент с чётко определённым интерфейсом. Алгоритм работы системы представляет собой последовательность взаимосвязанных процессов: установление соединения, аутентификация пользователя, синхронизация данных, криптографические операции над хранилищем, обработка пользовательских действий.

Для хранения данных используются специализированные хеш-таблицы с открытой адресацией, обеспечивающие эффективный доступ к информации. Криптографические операции выполняются с использованием библиотеки libsodium, гарантирующей современный уровень защиты данных.

### 2.4.1 Инициализация системы

**2.4.1.1 Инициализация серверной части:**
- Загрузка конфигурационных параметров (порт, пути к файлам)
- Инициализация библиотеки libsodium для криптографических операций
- Создание директорий для хранения данных (users.json, server_vaults/)
- Инициализация TCP-сокета для прослушивания входящих подключений
- Привязка сокета к указанному порту (bind)
- Перевод сокета в режим прослушивания (listen)

**2.4.1.2 Инициализация клиентской части:**
- Инициализация Qt Application и графического интерфейса
- Создание объекта Client с параметрами подключения к серверу
- Инициализация библиотеки libsodium на стороне клиента
- Настройка обработчиков событий UI (кнопки, формы ввода)
- Отображение главного меню приложения

**2.4.1.3 Подготовка структур данных:**
- Инициализация хеш-таблицы пользователей (HashTableUsers)
- Инициализация хеш-таблицы хранилища паролей (UserHashTable)
- Выделение памяти для буферов сетевого обмена

### 2.4.2 Обработка запросов аутентификации и регистрации

**2.4.2.1 Регистрация нового пользователя:**

*Клиентская сторона:*
1. Получение данных от пользователя (логин, пароль, кодовое слово)
2. Валидация введённых данных (проверка формата, длины)
3. Генерация seed-фразы восстановления (случайные слова из словаря)
4. Формирование JSON-запроса с типом "register"
5. Отправка запроса на сервер через TCP-соединение
6. Получение и обработка ответа сервера

*Серверная сторона:*
1. Приём и парсинг JSON-запроса
2. Извлечение параметров (username, password)
3. Валидация username и password (длина, допустимые символы)
4. Проверка уникальности логина в HashTableUsers
5. Генерация уникальной соли (salt) для пароля (32 байта)
6. Хеширование пароля с солью (Argon2)
7. Генерация соли для хранилища (vaultSalt)
8. Хеширование seed-фразы для восстановления
9. Сохранение данных пользователя в HashTableUsers
10. Запись обновлённой таблицы в users.json
11. Создание пустого зашифрованного хранилища для пользователя
12. Формирование и отправка JSON-ответа клиенту

**2.4.2.2 Вход в систему (Login):**

*Клиентская сторона:*
1. Получение учётных данных (логин, пароль, кодовое слово)
2. Формирование JSON-запроса с типом "login"
3. Отправка запроса на сервер
4. Получение ответа с vaultSalt и зашифрованным хранилищем
5. Деривация ключа шифрования из кодового слова и vaultSalt (PBKDF2)
6. Дешифрование хранилища с помощью AES-256-GCM
7. Десериализация JSON-данных хранилища
8. Загрузка записей в локальную структуру UserHashTable
9. Установка флага isLoggedIn = true
10. Переход к главному меню работы с паролями

*Серверная сторона:*
1. Приём и парсинг запроса авторизации
2. Поиск пользователя в HashTableUsers по логину
3. Извлечение сохранённого хеша пароля и соли
4. Хеширование предоставленного пароля с той же солью
5. Сравнение хешей (constant-time comparison)
6. При успешной проверке — чтение зашифрованного хранилища из файла
7. Формирование ответа с vaultSalt и зашифрованными данными
8. Отправка JSON-ответа клиенту

**2.4.2.3 Валидация сессии:**
- Проверка флага isLoggedIn перед выполнением операций
- Контроль времени жизни сессии (опционально)
- Защита от несанкционированного доступа к функциям

**2.4.2.4 Выход из системы (Logout):**
1. Очистка чувствительных данных из памяти (пароль, кодовое слово, ключи)
2. Освобождение памяти хранилища паролей
3. Сброс флага isLoggedIn = false
4. Возврат к экрану входа/регистрации

### 2.4.3 Обработка основных бизнес-запросов

**2.4.3.1 Работа с записями в хранилище:**

*Добавление новой записи (Add Entry):*
1. Получение данных от пользователя (сервис, логин, пароль, URL, заметка)
2. Получение текущей временной метки
3. Вставка записи в локальную UserHashTable (метод insert)
4. Вызов функции синхронизации с сервером (syncToServer)
5. Обновление отображения списка записей в UI

*Изменение существующей записи (Update Entry):*
1. Поиск записи по ключу (service + login)
2. Обновление полей (password, url, note)
3. Обновление временной метки lastModifiedTime
4. Синхронизация изменений с сервером
5. Обновление UI

*Удаление записи (Delete Entry):*
1. Поиск записи по ключу
2. Установка флага isDelete = true
3. Уменьшение счётчика записей в таблице
4. Синхронизация с сервером
5. Обновление UI

*Просмотр и поиск записей:*
1. Получение всех записей из UserHashTable (метод toJson)
2. Фильтрация по критериям поиска (service, login)
3. Отображение результатов в списке UI
4. Обработка клика для просмотра деталей записи

**2.4.3.2 Синхронизация с сервером:**

*Отправка изменений на сервер (syncToServer):*
1. Сериализация локального хранилища в JSON (метод toJson)
2. Деривация ключа шифрования из кодового слова и vaultSalt
3. Шифрование JSON-данных с помощью AES-256-GCM
4. Формирование запроса "update_vault" с зашифрованными данными
5. Отправка запроса на сервер через TCP
6. Получение подтверждения от сервера
7. Обработка ошибок при сбое синхронизации

*Получение изменений с сервера (syncFromServer):*
1. Формирование запроса "get_vault" с username
2. Отправка запроса на сервер
3. Получение зашифрованного хранилища
4. Дешифрование данных
5. Десериализация JSON
6. Обновление локальной UserHashTable
7. Обновление UI

**2.4.3.3 Управление паролями:**

*Генерация пароля:*
1. Получение параметров от пользователя (длина, набор символов)
2. Определение алфавита символов (uppercase, lowercase, digits, special)
3. Генерация криптостойкой случайной последовательности (randombytes_buf)
4. Выбор символов из алфавита на основе случайных байтов
5. Формирование строки пароля
6. Отображение результата пользователю
7. Опциональное копирование в буфер обмена

*Оценка стойкости пароля:*
1. Получение пароля для анализа
2. Проверка длины пароля
3. Определение разнообразия классов символов
4. Проверка наличия в словаре распространённых паролей (rockyou_1000k.txt)
5. Расчёт энтропии пароля
6. Вычисление оценки стойкости (слабый/средний/сильный/очень сильный)
7. Отображение результата с рекомендациями

### 2.4.4 Обработка специальных операций

**2.4.4.1 Восстановление пароля через seed-фразу:**

*Клиентская сторона:*
1. Получение логина, seed-фразы и нового пароля от пользователя
2. Формирование запроса "recover_password"
3. Отправка на сервер

*Серверная сторона:*
1. Поиск пользователя по логину
2. Извлечение сохранённого хеша seed-фразы
3. Хеширование предоставленной фразы
4. Сравнение хешей
5. При успехе — генерация новой соли
6. Хеширование нового пароля
7. Генерация новой seed-фразы и новой vaultSalt
8. Обновление данных пользователя в HashTableUsers
9. Перешифрование хранилища с новым ключом
10. Сохранение изменений

**2.4.4.2 Изменение мастер-пароля:**
1. Проверка текущей seed-фразы для подтверждения личности
2. Генерация новой соли для пароля
3. Хеширование нового пароля
4. Обновление учётных данных
5. Примечание: кодовое слово для хранилища не меняется

**2.4.4.3 Копирование пароля в буфер обмена:**
1. Извлечение пароля из выбранной записи
2. Использование QClipboard для копирования
3. Опционально — автоматическая очистка буфера через таймер (для безопасности)

### 2.4.5 Криптографические операции

**2.4.5.1 Хеширование пароля (Argon2):**
```
Вход: plaintext_password, salt
1. Использование crypto_pwhash для Argon2id
2. Параметры: OPSLIMIT_INTERACTIVE, MEMLIMIT_INTERACTIVE
3. Генерация 32-байтового хеша
Выход: password_hash (hex-строка)
```

**2.4.5.2 Генерация соли:**
```
1. Вызов randombytes_buf(buffer, 32)
2. Конвертация в hex-строку
Выход: 64-символьная hex-строка
```

**2.4.5.3 Шифрование хранилища (AES-256-GCM):**
```
Вход: json_data, vault_key
1. Сериализация данных в строку
2. Генерация nonce (12 байт)
3. Вызов crypto_aead_aes256gcm_encrypt
4. Формирование blob: nonce + ciphertext + tag
Выход: encrypted_blob (hex-строка)
```

**2.4.5.4 Дешифрование хранилища:**
```
Вход: encrypted_blob, vault_key
1. Парсинг blob: извлечение nonce, ciphertext, tag
2. Вызов crypto_aead_aes256gcm_decrypt
3. Проверка аутентификационного тега (AEAD)
4. Десериализация JSON
Выход: json_data или ошибка
```

**2.4.5.5 Деривация ключа шифрования (PBKDF2):**
```
Вход: code_word, vault_salt
1. Конвертация vault_salt из hex в байты
2. Вызов crypto_pwhash с параметрами для деривации ключа
3. Генерация 32-байтового ключа
Выход: vault_key (256 бит)
```

### 2.4.6 Система обработки данных

**2.4.6.1 Сетевой протокол взаимодействия:**

*Формат запроса:*
```json
{
  "type": "register|login|update_vault|get_vault|recover_password|change_password",
  "username": "user123",
  "password": "hashed_or_plain",
  "additional_fields": "..."
}
```

*Формат ответа:*
```json
{
  "status": "success|error",
  "message": "Описание результата",
  "data": {
    "vault_salt": "...",
    "encrypted_vault": "...",
    "seed_words": ["word1", "word2", ...]
  }
}
```

**2.4.6.2 Обработка TCP-соединений:**
1. Сервер ожидает входящих подключений (accept)
2. При подключении клиента создаётся новая сессия
3. Чтение данных из сокета (recv)
4. Парсинг JSON-запроса
5. Маршрутизация на соответствующий обработчик
6. Выполнение операции
7. Формирование JSON-ответа
8. Отправка ответа клиенту (send)
9. Закрытие соединения

**2.4.6.3 Персистентность данных:**

*Сохранение таблицы пользователей:*
1. Сериализация HashTableUsers в JSON
2. Запись в файл users.json
3. Атомарная операция записи (запись во временный файл + переименование)

*Сохранение хранилищ паролей:*
1. Создание файла username.vault в директории server_vaults/
2. Запись зашифрованных бинарных данных
3. Установка соответствующих прав доступа к файлу

### 2.4.7 Обработка ошибок

**2.4.7.1 Валидация входных данных:**

*При регистрации/авторизации:*
- Проверка длины логина (минимум 3, максимум 32 символа)
- Проверка допустимых символов в логине (alphanumeric + underscore)
- Проверка длины пароля (минимум 8 символов)
- Проверка наличия обязательных полей в JSON-запросе
- Возврат детальных сообщений об ошибках

*При работе с хранилищем:*
- Проверка корректности формата данных записи
- Валидация URL (опционально)
- Проверка лимита длины полей

**2.4.7.2 Обработка криптографических ошибок:**
- Перехват исключений при дешифровании (неверный ключ/повреждённые данные)
- Обработка сбоев AEAD-проверки (модификация данных)
- Сообщение пользователю о необходимости проверить кодовое слово

**2.4.7.3 Обработка сетевых ошибок:**
- Таймауты подключения к серверу
- Разрыв соединения во время передачи данных
- Недоступность сервера
- Повторные попытки подключения с экспоненциальной задержкой

**2.4.7.4 Обработка файловых операций:**
- Проверка существования файлов и директорий
- Обработка ошибок доступа (permissions)
- Обработка ошибок дискового пространства
- Логирование ошибок для диагностики

**2.4.7.5 Возврат структурированных ответов об ошибках:**
```json
{
  "status": "error",
  "message": "Описание ошибки для пользователя",
  "error_code": "ERROR_CODE",
  "details": "Техническая информация (опционально)"
}
```

**2.4.7.6 Обработка исключений:**
- Try-catch блоки для всех критических операций
- Graceful degradation при невозможности выполнения операции
- Откат изменений при сбое транзакций
- Безопасное завершение работы с очисткой ресурсов
