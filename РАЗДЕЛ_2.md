# 2. ОСНОВНАЯ ЧАСТЬ

## 2.2 Используемая информация

### 2.2.1 Данные пользователей и системы

**2.2.1.1 Учётные данные пользователя:**
- Логин (username) — уникальный идентификатор пользователя
- Хешированный пароль (passwordHash) — результат криптографического хеширования пароля с использованием соли
- Соль (salt) — случайная последовательность байтов для усиления стойкости хеша пароля
- Хеш seed-фразы (seedPhraseHash) — хешированная фраза восстановления для сброса пароля
- Соль хранилища (vaultSalt) — уникальная соль для шифрования персонального хранилища паролей пользователя

**2.2.1.2 Данные сессии:**
- Кодовое слово (codeWord) — мастер-ключ для шифрования/дешифрования хранилища паролей (хранится только на стороне клиента в оперативной памяти)
- Ключ шифрования хранилища (vaultKey) — производный ключ от кодового слова, используемый для AES-GCM шифрования
- Статус авторизации (isLoggedIn) — флаг активной сессии пользователя

**2.2.1.3 Системные настройки:**
- Порт сервера (по умолчанию 8080)
- Путь к файлу пользователей (users.json)
- Директория хранилищ паролей (server_vaults/)
- Параметры криптографии (размер ключей, алгоритмы хеширования и шифрования)

### 2.2.2 Сущности

**2.2.2.1 Пользователь (User):**

Хранится в структуре `HashTableUsers`:
- `login` (string) — логин пользователя
- `passwordHash` (string) — хеш пароля для аутентификации
- `salt` (string) — соль для хеширования пароля
- `seedPhraseHash` (string) — хеш seed-фразы для восстановления доступа
- `vaultSalt` (string) — соль для генерации ключа шифрования хранилища
- `isDelete` (bool) — флаг удаления записи
- `isNull` (bool) — флаг пустой ячейки хеш-таблицы

**2.2.2.2 Запись в хранилище паролей (VaultEntry):**

Хранится в структуре `UserHashTable`:
- `service` (string) — название сервиса/веб-сайта
- `login` (string) — логин для данного сервиса
- `password` (string) — пароль для данного сервиса (хранится в зашифрованном виде)
- `url` (string) — URL веб-сайта или адрес сервиса
- `note` (string) — дополнительные заметки или комментарии
- `lastModifiedTime` (string) — временная метка последнего изменения записи
- `isDelete` (bool) — флаг удаления записи
- `isNull` (bool) — флаг пустой ячейки хеш-таблицы

**2.2.2.3 Серверный компонент (Server):**
- `port` (int) — порт прослушивания TCP-соединений
- `serverSocket` (int) — дескриптор серверного сокета
- `usersFilePath` (string) — путь к файлу базы пользователей
- `vaultDirectory` (string) — директория хранения зашифрованных хранилищ

**2.2.2.4 Клиентский компонент (Client):**
- `serverHost` (string) — адрес сервера
- `serverPort` (int) — порт сервера
- `username` (string) — имя текущего пользователя
- `password` (string) — пароль (хранится только во время сессии)
- `codeWord` (string) — кодовое слово для шифрования хранилища
- `vault` (UserHashTable*) — локальная копия хранилища паролей
- `vaultKey` (vector<unsigned char>) — ключ шифрования хранилища
- `isLoggedIn` (bool) — статус авторизации

### 2.2.3 Данные мониторинга и логирования

**2.2.3.1 Сетевые операции:**
- TCP-соединения клиент-сервер
- JSON-запросы и ответы между компонентами системы
- Статусы операций (success/error) и коды ошибок

**2.2.3.2 Действия пользователей:**
- Регистрация новых пользователей
- Попытки входа в систему (успешные и неудачные)
- Операции с хранилищем (добавление, изменение, удаление записей)
- Синхронизация данных с сервером
- Восстановление доступа через seed-фразу

**2.2.3.3 Криптографические операции:**
- Генерация солей и ключей шифрования
- Операции хеширования паролей
- Шифрование и дешифрование хранилищ
- Валидация целостности зашифрованных данных

## 2.3 Результаты решения

Результатом решения задачи является функционирующий менеджер паролей с клиент-серверной архитектурой, предоставляющий:

1. **Графический интерфейс пользователя** на базе Qt Framework, обеспечивающий интуитивное взаимодействие со всеми функциями системы (регистрация, авторизация, управление паролями, оценка стойкости паролей).

2. **Серверную часть** для централизованного и безопасного хранения зашифрованных пользовательских данных с поддержкой множественных одновременных подключений.

3. **Систему криптографической защиты**, включающую:
   - Хеширование паролей с использованием Argon2 и уникальных солей
   - Шифрование хранилищ паролей с помощью AES-256-GCM
   - Генерацию криптостойких случайных паролей
   - Производные ключи на основе PBKDF2 для защиты данных

4. **Инструменты управления паролями:**
   - Генератор паролей с настраиваемыми параметрами (длина, набор символов)
   - Анализатор стойкости паролей с проверкой по словарям распространённых паролей
   - CRUD-операции для записей в хранилище
   - Поиск и фильтрация сохранённых паролей

5. **Механизм восстановления доступа** через seed-фразу (мнемоническую фразу восстановления).

6. **Возможность контейнеризации** серверной части с использованием Docker для упрощённого развёртывания.

## 2.4 Алгоритм решения задачи

Алгоритм решения задачи построен на архитектуре клиент-сервер с чётким разделением ответственности между компонентами. Клиентская часть, реализованная на базе Qt Framework, отвечает за пользовательский интерфейс, локальное управление хранилищем паролей и криптографические операции. Серверная часть на C++ обеспечивает сетевое взаимодействие, централизованное хранение зашифрованных данных и обработку запросов множественных клиентов. Для хранения данных используются хеш-таблицы с открытой адресацией, криптографические операции выполняются с использованием библиотеки libsodium.

### 2.4.1 Инициализация системы

**2.4.1.1 Инициализация сервера:**
Загрузка конфигурационных параметров, инициализация библиотеки libsodium, создание директорий для хранения данных (users.json, server_vaults/), инициализация и запуск TCP-сокета на указанном порту.

**2.4.1.2 Инициализация клиента:**
Инициализация Qt Application и GUI, создание объекта Client с параметрами подключения, инициализация libsodium, настройка обработчиков событий UI.

**2.4.1.3 Подготовка структур данных:**
Инициализация хеш-таблиц пользователей (HashTableUsers) и хранилища паролей (UserHashTable), выделение памяти для сетевых буферов.

### 2.4.2 Аутентификация и регистрация

**2.4.2.1 Регистрация:**
Клиент получает данные (логин, пароль, кодовое слово), валидирует их, генерирует seed-фразу и отправляет JSON-запрос на сервер. Сервер проверяет уникальность логина, генерирует соли (salt, vaultSalt), хеширует пароль (Argon2) и seed-фразу, сохраняет данные в HashTableUsers и users.json, создаёт пустое зашифрованное хранилище.

**2.4.2.2 Вход:**
Клиент отправляет учётные данные на сервер. Сервер проверяет хеш пароля (constant-time comparison), возвращает vaultSalt и зашифрованное хранилище. Клиент деривирует ключ из кодового слова (PBKDF2), дешифрует хранилище (AES-256-GCM), загружает записи в локальную структуру.

**2.4.2.3 Валидация сессии и выход:**
Проверка флага isLoggedIn перед операциями. При выходе — очистка чувствительных данных из памяти, освобождение ресурсов, возврат к экрану входа.

### 2.4.3 Работа с хранилищем паролей

**2.4.3.1 CRUD-операции:**
- **Добавление:** получение данных от пользователя, вставка в UserHashTable, синхронизация с сервером, обновление UI
- **Изменение:** поиск записи по ключу (service + login), обновление полей, синхронизация, обновление UI
- **Удаление:** установка флага isDelete, синхронизация с сервером
- **Просмотр:** получение записей из UserHashTable, фильтрация по критериям, отображение в UI

**2.4.3.2 Синхронизация:**
Сериализация хранилища в JSON, шифрование (AES-256-GCM), отправка на сервер через TCP. Обратная операция — получение зашифрованных данных, дешифрование, обновление локального хранилища.

**2.4.3.3 Генерация и оценка паролей:**
- **Генерация:** получение параметров (длина, символы), генерация криптостойкой случайной последовательности (randombytes_buf), формирование пароля
- **Оценка:** проверка длины, разнообразия символов, наличия в словаре распространённых паролей (rockyou_1000k.txt), расчёт энтропии, вывод рекомендаций

### 2.4.4 Восстановление и изменение учётных данных

**2.4.4.1 Восстановление через seed-фразу:**
Проверка хеша seed-фразы на сервере, генерация новых солей, хеширование нового пароля, генерация новой seed-фразы, перешифрование хранилища с новым ключом.

**2.4.4.2 Изменение мастер-пароля:**
Проверка seed-фразы для подтверждения, генерация новой соли, хеширование нового пароля, обновление учётных данных.

### 2.4.5 Криптографические операции

**2.4.5.1 Хеширование (Argon2):**
Использование crypto_pwhash с параметрами OPSLIMIT_INTERACTIVE и MEMLIMIT_INTERACTIVE для генерации 32-байтового хеша пароля.

**2.4.5.2 Шифрование хранилища (AES-256-GCM):**
Сериализация данных, генерация nonce (12 байт), вызов crypto_aead_aes256gcm_encrypt, формирование blob: nonce + ciphertext + tag.

**2.4.5.3 Дешифрование хранилища:**
Парсинг blob, извлечение nonce и ciphertext, вызов crypto_aead_aes256gcm_decrypt с проверкой аутентификационного тега (AEAD).

**2.4.5.4 Деривация ключа (PBKDF2):**
Использование crypto_pwhash для генерации 32-байтового ключа из кодового слова и vaultSalt.

### 2.4.6 Сетевое взаимодействие и персистентность

**2.4.6.1 Протокол взаимодействия:**
JSON-формат запросов/ответов с полями type, username, password, data. Типы запросов: register, login, update_vault, get_vault, recover_password, change_password.

**2.4.6.2 TCP-соединения:**
Сервер ожидает подключений (accept), читает данные (recv), парсит JSON, маршрутизирует на обработчики, выполняет операции, отправляет ответ (send), закрывает соединение.

**2.4.6.3 Персистентность:**
Сохранение HashTableUsers в users.json (атомарная операция). Сохранение зашифрованных хранилищ в файлы username.vault в директории server_vaults/.

### 2.4.7 Обработка ошибок

**2.4.7.1 Валидация данных:**
Проверка длины и формата логина/пароля, наличия обязательных полей, корректности данных записей.

**2.4.7.2 Криптографические ошибки:**
Перехват исключений при дешифровании, обработка сбоев AEAD-проверки, информирование пользователя.

**2.4.7.3 Сетевые ошибки:**
Обработка таймаутов, разрывов соединения, недоступности сервера, повторные попытки с экспоненциальной задержкой.

**2.4.7.4 Файловые операции:**
Проверка существования файлов/директорий, обработка ошибок доступа и дискового пространства, логирование.

**2.4.7.5 Структурированные ответы:**
Возврат JSON с полями status, message, error_code, details. Try-catch блоки для критических операций, graceful degradation, откат при сбоях.
